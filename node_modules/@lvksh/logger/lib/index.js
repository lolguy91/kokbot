"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shimLog = exports.createLogger = exports.pad = exports.resolveRuntimeOrValue = void 0;
const util_1 = require("util");
const ansi_1 = require("./ansi");
const resolveRuntimeOrValue = (rov) => {
    return (typeof rov === 'function' ? rov() : rov);
};
exports.resolveRuntimeOrValue = resolveRuntimeOrValue;
const pad = (text, length, paddingStrategy, paddingChar) => {
    if (paddingStrategy === 'NONE')
        return text;
    const calculatedPadding = paddingChar.repeat(''.padStart(length - (0, ansi_1.stripAnsi)(text).length, ' ').length);
    if (paddingStrategy === 'APPEND')
        return text + calculatedPadding;
    if (paddingStrategy === 'PREPEND')
        return calculatedPadding + text;
};
exports.pad = pad;
/**
 * @name createLogger
 * Creates a logger with the specified methods and config
 * Able to output to a logging function
 * @param methods Config of logging methods
 * @param [config] Logger-wide configuration
 * @param [func=console.log] Custom logging function
 */
const createLogger = (methods, config = {}, func = console.log) => {
    let functions = Array.isArray(func) ? func : [func];
    // If methods is a MethodList, use it, otherwise grab a random instance
    const finalMethods = Array.isArray(methods)
        ? methods[Math.floor(Math.random() * methods.length)]
        : methods;
    // Fill default values incase not overridden by arg
    const completeConfig = Object.assign({
        divider: ' ',
        newLine: '├-',
        newLineEnd: '└-',
        padding: 'PREPEND',
        paddingChar: ' ',
        color: true,
        exclude: [],
        filter: undefined,
    }, config);
    // Infer the default method config
    const inferredMethodConfig = {
        label: '-',
        newLine: completeConfig.newLine,
        newLineEnd: completeConfig.newLineEnd,
        divider: completeConfig.divider,
        paddingChar: completeConfig.paddingChar,
        tags: ['default'],
    };
    // Convert all string methods to MethodConfig
    const completeMethods = Object.assign({}, ...Object.keys(finalMethods).map((a) => {
        if (typeof finalMethods[a] == 'string') {
            // Return an inferred MethodConfig
            return {
                [a]: Object.assign(Object.assign({}, inferredMethodConfig), {
                    label: finalMethods[a],
                }),
            };
        }
        // Return the MethodConfig that was provided
        return {
            [a]: Object.assign(Object.assign({}, inferredMethodConfig), finalMethods[a]),
        };
    }));
    // Calculate the max length
    const maxLength = Math.max(...Object.values(completeMethods).map((a) => typeof a.label === 'string'
        ? (0, ansi_1.stripAnsi)(a.label).length
        : a.label.length));
    return Object.assign({}, ...Object.keys(completeMethods).map((methodHandle) => {
        const method = completeMethods[methodHandle];
        const [paddedText, newLinePadding, newLineEndPadding] = [
            typeof method.label === 'string'
                ? (0, exports.pad)(method.label, maxLength, completeConfig.padding, method.paddingChar)
                : '',
            (0, exports.pad)(method.newLine, maxLength, completeConfig.padding, method.paddingChar),
            (0, exports.pad)(method.newLineEnd, maxLength, completeConfig.padding, method.paddingChar),
        ];
        return {
            [methodHandle]: (...s) => {
                const filter = (0, exports.resolveRuntimeOrValue)(completeConfig.filter);
                const exclude = (0, exports.resolveRuntimeOrValue)(completeConfig.exclude);
                // Decide wether this should be filtered or not
                if (filter && filter !== undefined
                    ? !method.tags.some((r) => filter.includes(r))
                    : method.tags.some((r) => exclude.includes(r)))
                    return;
                // Generate the value we should output
                const value = s
                    .map((value) => {
                    if (typeof value !== 'string') {
                        value = (0, util_1.inspect)(value, false, 3, completeConfig.color);
                    }
                    return value;
                })
                    .join('\n')
                    .split('\n')
                    .map((value, index, array) => (index == 0
                    ? (typeof method.label === 'string'
                        ? paddedText
                        : (0, exports.pad)(method.label.calculate(), maxLength, completeConfig.padding, method.paddingChar)) + method.divider
                    : (array.length - 1 == index
                        ? newLineEndPadding
                        : newLinePadding) + method.divider) +
                    value)
                    .join('\n');
                // Run each of the final functions
                functions.forEach((a) => a(value));
            },
        };
    }));
};
exports.createLogger = createLogger;
const shimLog = (logger, func) => {
    Object.defineProperty(console, 'log', {
        value: logger[func],
    });
};
exports.shimLog = shimLog;
