import type { Hashable } from './util';
/**
 * 64-bit unsigned addition
 * Sets v[a, a+1] += v[b, b+1]
 */
export declare function ADD64AA(
	v: Uint32Array,
	a: number,
	b: number
): Uint32Array;
/**
 * 64-bit unsigned addition
 * Set v[a, a+1] += b
 * @param b0 the low 32 bits of b
 * @param b1 the high 32 bits of b
 * @returns
 */
export declare function ADD64AC(
	v: Uint32Array,
	a: number,
	b0: number,
	b1: number
): Uint32Array;
/**
 * Little-endian byte access
 */
export declare function B2B_GET32(arr: Uint8Array, i: number): number;
/**
 * G Mixing function
 * ROTRs are inlined to increase performance
 */
export declare function B2B_G(
	a: number,
	b: number,
	c: number,
	d: number,
	ix: number,
	iy: number
): void;
/**
 * Initialization Vector
 */
export declare const BLAKE2B_IV32: Uint32Array;
export declare const SIGMA8: number[];
/**
 * These are offsets into a uint64 buffer.
 * Multiply them all by 2 to make them offsets into a uint32 buffer,
 * because this is JavaScript and we don't have uint64s
 */
export declare const SIGMA82: Uint8Array;
/**
 * Compressing function.
 * We're representing 16 Uint64s as 32 Uint32s.
 * @param ctx the hashing context
 * @param last Is this the last block?
 */
export declare function blake2bCompress(ctx: Blake2bCTX, last?: boolean): void;
export interface Blake2bCTX {
	b: Uint8Array;
	h: Uint32Array;
	t: number;
	c: number;
	outlen: number;
}
/**
 * Creates a Blake2b hashing context
 * @param outlen between 1 and 64
 * @param key optional
 * @returns
 */
export declare function blake2bInit(
	outlen?: number,
	key?: Uint8Array
): Blake2bCTX;
/**
 * Updates a Blake2b streaming hash
 * @param ctx hashing context from blake2bInit()
 * @param input Byte array
 */
export declare function blake2bUpdate(
	ctx: Blake2bCTX,
	input: ArrayLike<number>
): void;
/**
 * Completes a Blake2b streaming hash
 * @param ctx hashing context from blake2bInit()
 * @returns the final hash
 */
export declare function blake2bFinal(ctx: Blake2bCTX): Uint8Array;
/**
 *
 * @param input the input bytes, as a string, Buffer, or Uint8Array
 * @param key optional key Uint8Array, up to 64 bytes
 * @param outlen optional output length in bytes, defaults to 64
 * @returns an n-byte Uint8Array
 */
export declare function blake2b(
	input: Hashable,
	key?: Uint8Array,
	outlen?: number
): Uint8Array;
/**
 * Computes the Blake2b hash of a string or byte array
 *
 * @param input the input bytes, as a string, Buffer, or Uint8Array
 * @param key optional key Uint8Array, up to 64 bytes
 * @param outlen outlen - optional output length in bytes, defaults to 64
 * @returns an n-byte hash in hex, all lowercase
 */
export declare function blake2bHex(
	input: Hashable,
	key?: Uint8Array,
	outlen?: number
): string;
/**
 *
 * @param input the input bytes, as a string, Buffer, or Uint8Array
 * @param key optional key Uint8Array, up to 32 bytes
 * @param outlen optional output length in bytes, defaults to 64
 * @returns the hash, as a bigint
 */
export declare function blake2bBigInt(
	input: Hashable,
	key?: Uint8Array,
	outlen?: number
): bigint;
