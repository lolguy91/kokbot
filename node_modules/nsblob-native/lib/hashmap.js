'use strict';
var __importDefault =
	(this && this.__importDefault) ||
	function (mod) {
		return mod && mod.__esModule ? mod : { default: mod };
	};
Object.defineProperty(exports, '__esModule', { value: true });
exports.HashMap = void 0;
const semaphore_1 = require('@prokopschield/semaphore');
const fs_1 = __importDefault(require('fs'));
const insta_db_1 = require('insta-db');
const os_1 = __importDefault(require('os'));
const path_1 = __importDefault(require('path'));
class HashMap extends insta_db_1.DB {
	constructor() {
		const directory = path_1.default.resolve(
			os_1.default.homedir(),
			'.cache',
			'nsblob-native'
		);
		if (!fs_1.default.existsSync(directory)) {
			fs_1.default.mkdirSync(directory);
		}
		const storage_file = path_1.default.resolve(directory, 'hashmap');
		super({
			read_only_files: [],
			size: 1024 * 1024 * 1024,
			storage_copies: [],
			storage_file,
		});
		this.semaphore = new semaphore_1.Semaphore('nsblob-native-hashmap');
	}
	setB2H(blake, hash) {
		if (!this.semaphore.wait()) {
			return undefined;
		}
		const returnValue = this.set(
			Buffer.from(blake, 'hex'),
			Buffer.from(hash, 'hex')
		);
		this.semaphore.post();
		return returnValue;
	}
	getB2H(blake) {
		if (!this.semaphore.wait()) {
			return undefined;
		}
		const returnValue = this.get(Buffer.from(blake, 'hex')) || '';
		this.semaphore.post();
		return returnValue.toString('hex') || undefined;
	}
}
exports.HashMap = HashMap;
