'use strict';
var __importDefault =
	(this && this.__importDefault) ||
	function (mod) {
		return mod && mod.__esModule ? mod : { default: mod };
	};
Object.defineProperty(exports, '__esModule', { value: true });
exports.fetch = void 0;
const fs_1 = __importDefault(require('fs'));
const path_1 = __importDefault(require('path'));
const ps_std_1 = require('ps-std');
const serial_async_io_1 = __importDefault(require('serial-async-io'));
const utils_1 = require('./utils');
const write_queue = new ps_std_1.Queue(console.error);
async function fetch(hash, where, exclude = /node_modules/) {
	const entry = await (0, utils_1.fetch_object)(hash);
	const filename = path_1.default.resolve(where, entry.name);
	if (
		!(0, utils_1.check_filename)(entry.name) &&
		!(entry.type === 'directory' && entry.name === '.')
	) {
		throw new Error(`${entry.name} is not a valid filename!`);
	}
	if (filename.match(exclude)) {
		return 0;
	}
	switch (entry.type) {
		case 'directory': {
			await fs_1.default.promises.mkdir(filename, { recursive: true });
			const count = await Promise.all(
				entry.children.map((hash) => fetch(hash, filename))
			);
			return count.reduce((a, b) => a + b, 0);
		}
		case 'file': {
			const data = await (0, utils_1.fetch_buffer)(entry.hash);
			await serial_async_io_1.default.write(filename, data);
			return entry.size;
		}
		case 'longfile': {
			await write_queue.promise;
			const stream = fs_1.default.createWriteStream(filename);
			for (const part of entry.parts) {
				stream.write(await (0, utils_1.fetch_buffer)(part));
			}
			stream.end(() => {
				write_queue.next_async();
			});
			return entry.size;
		}
	}
}
exports.fetch = fetch;
