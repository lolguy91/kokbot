'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.SerialQueue = void 0;
const Queue_1 = require('./Queue');
class SerialQueue {
	constructor(error_handler) {
		this._donecb = () => {};
		this.error_handler = error_handler;
		this._queue = new Queue_1.Queue(error_handler);
	}
	/** Internal queue array */
	get queue() {
		return this._queue.queue;
	}
	/** Is something being processed? */
	get working() {
		return this._queue.working;
	}
	/** Function that forces queue to process next callback */
	next_async() {
		setTimeout(this.next);
	}
	/** Function that forces queue to process next callback */
	get next() {
		const self = this;
		return () => {
			self._queue.next();
			setTimeout(() => {
				if (!this._queue.queue.length && !this._queue.working) {
					this._donecb();
				}
			});
		};
	}
	/** Add callback(s) to queue */
	get add() {
		const self = this;
		return (...callbacks) => {
			for (const cb of callbacks) {
				this._queue.add(async () => {
					try {
						await cb();
					} catch (error) {
						if (this.error_handler) {
							this.error_handler(error);
						} else {
							throw error;
						}
					}
					self.next_async();
				});
			}
		};
	}
	/** Get a Promise that will resolve once CURRENT callbacks are done */
	get promise() {
		const self = this;
		return new Promise((resolve) => self.add(resolve));
	}
	get done() {
		if (this._done) {
			return this._done;
		} else {
			const self = this;
			return (self._done = new Promise(async (resolve) => {
				self._donecb = () => {
					self._done = undefined;
					resolve();
				};
				await self.promise;
			}));
		}
	}
}
exports.SerialQueue = SerialQueue;
exports.default = SerialQueue;
Object.defineProperties(SerialQueue, {
	default: { get: () => SerialQueue },
	SerialQueue: { get: () => SerialQueue },
});
