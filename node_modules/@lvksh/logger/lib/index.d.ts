export declare type LogMethodInput = string | object;
export declare type LogMethod = (...input: LogMethodInput[]) => void;
export declare type Logger<K extends string> = {
    [a in K]: LogMethod;
};
export declare type RuntimeOrValue<K> = (() => K) | K;
export declare type PadType = 'PREPEND' | 'APPEND' | 'NONE';
export declare type SharedConfig = {
    /**
     * The character to be used when a line needs to be broken
     * This overrides any value set by the logger
     * @default "├-"
     */
    newLine?: string;
    /**
     * The character to be used when the last line needs to be broken
     * This overrides any value set by the logger
     * @default "└-"
     */
    newLineEnd?: string;
    /**
     * The divider between the label and the payload
     * This overrides any value set by the logger
     * @default " "
     */
    divider?: string;
    /**
     * The character used to pad
     * @default " "
     */
    paddingChar?: string;
};
export declare type LogConfig = SharedConfig & {
    /**
     * Wether to add spacing in front or behind the specified label
     * @default "PREPEND"
     */
    padding: PadType;
    /**
     * Util.inspect color highlighting
     * @default true
     */
    color: boolean;
    /**
     * List of tags to be ignored
     * @default [] (empty array)
     * @example ['debug'] (ignores all debug messages)
     */
    exclude: RuntimeOrValue<string[]>;
    /**
     * List of tags to only log
     * If defined overrides `exclude`
     * @default undefined
     * @example ['error', 'important', 'success'] (only logs error, important, and success)
     */
    filter: RuntimeOrValue<string[] | undefined>;
};
/**
 * Dynamically generated label.
 * complexity: O(n)
 */
export declare type RuntimeLabel = {
    /**
     * Label length to be reserved for calculated answer
     */
    length: number;
    /**
     * Executed on log, value returned becomes label
     */
    calculate: () => string;
};
/**
 * Pre generated label.
 * complexity: O(1)
 */
export declare type StaticLabel = string;
export declare type MethodConfig = SharedConfig & {
    /**
     * The label used to prefix log messages.
     * Used for organization and sorting purposes.
     * May contain ansi color codes!
     */
    label: StaticLabel | RuntimeLabel;
    /**
     * An array of tags to be used for filtering
     * @default ['default']
     * @example ['default', 'debug']
     */
    tags?: string[];
};
declare type GenericLogFunction = (input: string) => void;
declare type MethodList<A extends string> = {
    [k in A]: string | MethodConfig;
};
export declare const resolveRuntimeOrValue: <K>(rov: RuntimeOrValue<K>) => K;
export declare const pad: (text: string, length: number, paddingStrategy: PadType, paddingChar: string) => string | undefined;
/**
 * @name createLogger
 * Creates a logger with the specified methods and config
 * Able to output to a logging function
 * @param methods Config of logging methods
 * @param [config] Logger-wide configuration
 * @param [func=console.log] Custom logging function
 */
export declare const createLogger: <A extends string>(methods: MethodList<A> | MethodList<A>[], config?: Partial<LogConfig>, func?: GenericLogFunction | GenericLogFunction[]) => Logger<A>;
export declare const shimLog: <A extends string>(logger: Logger<A>, func: A) => void;
export {};
