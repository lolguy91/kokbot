'use strict';
var __importDefault =
	(this && this.__importDefault) ||
	function (mod) {
		return mod && mod.__esModule ? mod : { default: mod };
	};
Object.defineProperty(exports, '__esModule', { value: true });
exports.finished = exports.write = exports.read = exports.stat = void 0;
const fs_1 = __importDefault(require('fs'));
const path_1 = __importDefault(require('path'));
let wake = () => void trigger();
const state = {
	toStat: new Set(),
	toRead: new Set(),
	toWrite: new Set(),
	statPromises: new Map(),
	statCallbacks: new Map(),
	readPromises: new Map(),
	readCallbacks: new Map(),
	toReadLater: new Set(),
};
function stat(file_path) {
	file_path = path_1.default.resolve(file_path);
	if (state.statPromises.has(file_path)) {
		return state.statPromises.get(file_path) || stat(file_path);
	}
	const promise = new Promise((resolve) => {
		state.statCallbacks.set(file_path, (b) => resolve(b));
		state.toStat.add(file_path);
		wake();
	});
	state.statPromises.set(file_path, promise);
	return promise;
}
exports.stat = stat;
/**
 * Asynchronously read a file
 * @param file_path Path to file, resolved to absolute path upon call
 * @returns Promise of read buffer
 */
function read(file_path) {
	file_path = path_1.default.resolve(file_path);
	if (state.readPromises.has(file_path)) {
		return state.readPromises.get(file_path) || read(file_path);
	}
	const promise = new Promise((resolve) => {
		state.readCallbacks.set(file_path, (b) => resolve(b));
		state.toRead.add(file_path);
		wake();
	});
	state.readPromises.set(file_path, promise);
	return promise;
}
exports.read = read;
/**
 * Asynchronously write to a file
 * @param file_path Path to file, resolved to absolute path upon call
 * @param data Data `string` or `Buffer`
 * @returns A promise that resolves to undefined
 */
function write(file_path, data) {
	file_path = path_1.default.resolve(file_path);
	return new Promise((resolve, reject) => {
		// Don't keep a referrence to the data object
		state.toWrite.add([
			file_path,
			resolve,
			reject,
			typeof data === 'string' ? data : Buffer.from(data),
		]);
		wake();
	});
}
exports.write = write;
async function trigger() {
	var _a, _b;
	wake = () => void null;
	try {
		for (const to_stat of state.toStat.values()) {
			const stat = await fs_1.default.promises
				.stat(to_stat)
				.catch(() => false);
			(_a = state.statCallbacks.get(to_stat)) === null || _a === void 0
				? void 0
				: _a(stat);
			state.statCallbacks.delete(to_stat);
			state.statPromises.delete(to_stat);
			state.toStat.delete(to_stat);
		}
		for (const to_write of state.toWrite.values()) {
			const [file, cb, reject, buf] = to_write;
			try {
				await fs_1.default.promises.writeFile(file, buf);
				cb();
			} catch (error) {
				reject(error);
			}
			state.toWrite.delete(to_write);
		}
		for (const to_read of state.toRead.values()) {
			try {
				const data = await fs_1.default.promises.readFile(to_read);
				(_b = state.readCallbacks.get(to_read)) === null ||
				_b === void 0
					? void 0
					: _b(data);
				state.readCallbacks.delete(to_read);
				state.readPromises.delete(to_read);
				state.toReadLater.delete(to_read);
			} catch (error) {
				state.toReadLater.add(to_read);
			}
			state.toRead.delete(to_read);
		}
	} catch (error) {
		wake = () => void trigger();
		return void setTimeout(() => wake());
	}
	wake = () => void trigger();
	if (state.toRead.size || state.toWrite.size) {
		setTimeout(wake);
	} else if (state.toReadLater.size) {
		for (const entry of state.toReadLater) {
			state.toRead.add(entry);
		}
	} else {
		const cb = finished_callback_array.shift();
		if (cb) cb(finished_callback_array.length);
	}
}
/** Internal array of callbacks */
const finished_callback_array = Array();
/**
 * Add a custom callback
 * gets called once, when all io is finished
 */
const add_finished_callback = (cb) => finished_callback_array.push(cb);
/**
 * Get a Promise
 * gets resolved when all io is finished
 */
const get_finished_promise = () =>
	new Promise((resolve) =>
		finished_callback_array.push(() =>
			resolve(finished_callback_array.length)
		)
	);
exports.finished = {
	callbacks: finished_callback_array,
	add_callback: add_finished_callback,
	get_promise: get_finished_promise,
};
Object.freeze(exports.finished);
const def = { read, write, stat, finished: exports.finished };
const prop = { get: () => def };
Object.defineProperties(def, { def: prop, default: prop });
exports.default = def;
